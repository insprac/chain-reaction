/// Provides a hexagon grid system for bevy that uses a cube coordinate system.
///
/// This module was generated by Gemini 2.5 Pro.
///
/// Reference: https://www.redblobgames.com/grids/hexagons/#coordinates-cube.

use bevy::prelude::*;
use bevy::reflect::Reflect;
use std::ops::{Add, Mul, Sub};

const SQRT_3: f32 = 1.732050807568877293527446341505872367_f32;

/// Array of all 6 directional vectors for cube coordinates.
/// These are used to find neighbors.
/// (q, r, s)
/// Order: E, NE, NW, W, SW, SE (for pointy top, moving clockwise)
/// Or: SE, S, SW, NW, N, NE (for flat top, moving clockwise)
#[rustfmt::skip]
pub const HEX_DIRECTIONS: [HexCoord; 6] = [
    HexCoord::new_unchecked(1, 0, -1),  // E / SE
    HexCoord::new_unchecked(1, -1, 0), // NE / S
    HexCoord::new_unchecked(0, -1, 1),  // NW / SW
    HexCoord::new_unchecked(-1, 0, 1), // W / NW
    HexCoord::new_unchecked(-1, 1, 0),  // SW / N
    HexCoord::new_unchecked(0, 1, -1),   // SE / NE
];

pub struct HexGridPlugin;

impl Plugin for HexGridPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<HexCoord>()
            .register_type::<HexOrientation>()
            .register_type::<HexLayout>();

        if !app.world().contains_resource::<HexLayout>() {
            app.insert_resource(HexLayout::default());
        }
    }
}

/// Represents a hexagonal grid coordinate using the cube coordinate system (q, r, s).
///
/// Invariants:
/// - `q + r + s == 0` must always hold true.
///
/// Cube coordinates are very convenient for hex grid algorithms.
/// - `q` corresponds to one axis (e.g., x-like).
/// - `r` corresponds to another axis (e.g., y-like or z-like).
/// - `s` is derived: `s = -q - r`.
///
/// See https://www.redblobgames.com/grids/hexagons/#coordinates-cube for more details.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Component, Reflect, Default)]
#[reflect(Component)]
pub struct HexCoord {
    pub q: i32,
    pub r: i32,
    pub s: i32,
}

impl HexCoord {
    /// Creates a new `HexCoord` from q, r, and s components.
    /// Panics if `q + r + s != 0`.
    pub fn new(q: i32, r: i32, s: i32) -> Self {
        if q + r + s != 0 {
            panic!(
                "HexCoord invariant failed: q + r + s must be 0. Got q={}, r={}, s={}",
                q, r, s
            );
        }
        Self { q, r, s }
    }

    /// Creates a new `HexCoord` from q and r (axial coordinates), deriving s.
    /// This is a common way to define hex coordinates as s is dependent.
    pub fn from_axial(q: i32, r: i32) -> Self {
        Self { q, r, s: -q - r }
    }

    /// Unchecked constructor, useful for constants where the invariant is known.
    /// **Use with caution.**
    pub(crate) const fn new_unchecked(q: i32, r: i32, s: i32) -> Self {
        // In a const context, we can't panic, so this relies on correctness.
        // debug_assert!(q + r + s == 0, "HexCoord invariant failed");
        Self { q, r, s }
    }

    /// The origin hex coordinate (0, 0, 0).
    pub fn origin() -> Self {
        Self { q: 0, r: 0, s: 0 }
    }

    /// Returns the direction vector for a given index (0-5).
    /// Corresponds to `HEX_DIRECTIONS`.
    pub fn direction(index: usize) -> Self {
        HEX_DIRECTIONS[index % 6]
    }

    /// Returns the neighbor of this hex in the given direction index.
    pub fn neighbor(&self, direction_index: usize) -> Self {
        *self + Self::direction(direction_index)
    }

    /// Returns an iterator over all 6 neighbors of this hex.
    pub fn neighbors(&self) -> impl Iterator<Item = HexCoord> + '_ {
        HEX_DIRECTIONS.iter().map(move |&dir| *self + dir)
    }

    /// Calculates the Manhattan distance between two hex coordinates.
    pub fn distance(&self, other: &Self) -> u32 {
        ((self.q - other.q).abs() + (self.r - other.r).abs() + (self.s - other.s).abs()) as u32 / 2
    }

    /// Calculates the length of the coordinate vector (distance from origin).
    pub fn length(&self) -> u32 {
        self.distance(&Self::origin())
    }

    /// Rounds fractional cube coordinates to the nearest integer hex coordinate.
    /// This is crucial for converting world positions back to hexes.
    pub fn round(fq: f32, fr: f32, fs: f32) -> Self {
        let mut q = fq.round();
        let mut r = fr.round();
        let mut s = fs.round();

        let q_diff = (q - fq).abs();
        let r_diff = (r - fr).abs();
        let s_diff = (s - fs).abs();

        if q_diff > r_diff && q_diff > s_diff {
            q = -r - s;
        } else if r_diff > s_diff {
            r = -q - s;
        } else {
            s = -q - r;
        }
        // Ensure the invariant holds after rounding.
        // It's possible for rounding to be off by one due to floating point inaccuracies,
        // so we explicitly enforce the s = -q -r relationship for the final result.
        Self::from_axial(q as i32, r as i32)
    }

    /// Linear interpolation between two hex coordinates.
    pub fn lerp(a: Self, b: Self, t: f32) -> (f32, f32, f32) {
        (
            a.q as f32 + (b.q - a.q) as f32 * t,
            a.r as f32 + (b.r - a.r) as f32 * t,
            a.s as f32 + (b.s - a.s) as f32 * t,
        )
    }

    /// Generates a line of hex coordinates between `a` and `b` (inclusive).
    pub fn linedraw(a: Self, b: Self) -> Vec<Self> {
        let n = a.distance(&b);
        if n == 0 {
            return vec![a];
        }
        let mut results = Vec::with_capacity((n + 1) as usize);
        for i in 0..=n {
            let t = i as f32 / n as f32;
            let (fq, fr, fs) = Self::lerp(a, b, t);
            results.push(Self::round(fq, fr, fs));
        }
        results
    }

    /// Generates a ring of hexes at a given `radius` around this coordinate.
    pub fn ring(&self, radius: u32) -> Vec<HexCoord> {
        if radius == 0 {
            return vec![*self];
        }
        let mut results = Vec::new();
        // Start at radius steps in one direction (e.g., 4th direction: (-radius, +radius, 0) relative)
        let mut current = *self + HEX_DIRECTIONS[4] * (radius as i32);
        // Then walk around the ring
        for i in 0..6 {
            // For each of the 6 sides of the hexagon
            for _j in 0..radius {
                // For each step along that side
                results.push(current);
                current = current.neighbor(i);
            }
        }
        results
    }

    /// Generates a filled hexagon (or disk) of hexes up to `radius` around this coordinate.
    pub fn filled_disk(&self, radius: u32) -> Vec<HexCoord> {
        let mut results = Vec::new();
        for q_offset in -(radius as i32)..=(radius as i32) {
            let r_min = (-(radius as i32)).max(-q_offset - (radius as i32));
            let r_max = (radius as i32).min(-q_offset + (radius as i32));
            for r_offset in r_min..=r_max {
                results.push(*self + HexCoord::from_axial(q_offset, r_offset));
            }
        }
        results
    }
}

// --- Operator Overloads for HexCoord ---

impl Add for HexCoord {
    type Output = Self;
    fn add(self, rhs: Self) -> Self::Output {
        Self::from_axial(self.q + rhs.q, self.r + rhs.r)
    }
}

impl Sub for HexCoord {
    type Output = Self;
    fn sub(self, rhs: Self) -> Self::Output {
        Self::from_axial(self.q - rhs.q, self.r - rhs.r)
    }
}

impl Mul<i32> for HexCoord {
    type Output = Self;
    fn mul(self, rhs: i32) -> Self::Output {
        Self::from_axial(self.q * rhs, self.r * rhs)
    }
}

// --- HexOrientation & HexLayout ---

/// Defines the orientation of the hexagons in the grid.
/// - `Pointy`: Hexagons are pointy-topped. q-axis points right-east, r-axis points south-east.
/// - `Flat`: Hexagons are flat-topped. q-axis points east, r-axis points south-east.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Reflect)]
pub enum HexOrientation {
    Pointy,
    Flat,
}

/// Stores layout information for converting between hex coordinates and world space.
/// This includes hex orientation, size, and the grid's origin offset in world space.
#[derive(Debug, Clone, Copy, Reflect, Resource)]
#[reflect(Resource)]
pub struct HexLayout {
    pub orientation: HexOrientation,
    /// Size of a hex: distance from center to a corner.
    pub hex_size: Vec2,
    /// World space offset of the hex grid's origin (0,0,0) coordinate.
    /// The y-component of this offset is typically used as the base height for a flat grid.
    pub origin_offset: Vec3,
}

impl Default for HexLayout {
    fn default() -> Self {
        Self {
            orientation: HexOrientation::Flat,
            hex_size: Vec2::ONE, // Default size of 1 unit radius
            origin_offset: Vec3::ZERO,
        }
    }
}

impl HexLayout {
    /// Creates a new `HexLayout`.
    pub fn new(orientation: HexOrientation, hex_size: Vec2, origin_offset: Vec3) -> Self {
        Self {
            orientation,
            hex_size,
            origin_offset,
        }
    }

    /// Converts a `HexCoord` to its corresponding 3D world space position.
    /// The y-coordinate in world space is determined by `self.origin_offset.y`.
    /// For terrain or variable height, this y-value would need further adjustment.
    pub fn hex_to_world_3d(&self, hex: HexCoord) -> Vec3 {
        let x: f32;
        let z: f32; // Using z for the other 2D plane axis in 3D

        match self.orientation {
            HexOrientation::Pointy => {
                x = self.hex_size.x * (SQRT_3 * hex.q as f32 + SQRT_3 / 2.0 * hex.r as f32);
                z = self.hex_size.y * (3.0 / 2.0 * hex.r as f32);
            }
            HexOrientation::Flat => {
                x = self.hex_size.x * (3.0 / 2.0 * hex.q as f32);
                z = self.hex_size.y * (SQRT_3 / 2.0 * hex.q as f32 + SQRT_3 * hex.r as f32);
            }
        }
        Vec3::new(x, 0.0, z) + self.origin_offset
    }

    /// Converts a 3D world space position to the corresponding (fractional) `HexCoord`.
    /// The y-component of `world_pos` is ignored for this conversion, assuming a flat plane.
    /// The result is fractional and needs to be rounded using `HexCoord::round` to get an integer `HexCoord`.
    pub fn world_to_hex_fractional(&self, world_pos: Vec3) -> (f32, f32, f32) {
        let pt = Vec2::new(
            (world_pos.x - self.origin_offset.x) / self.hex_size.x,
            (world_pos.z - self.origin_offset.z) / self.hex_size.y,
        );

        let fq: f32;
        let fr: f32;

        match self.orientation {
            HexOrientation::Pointy => {
                fq = SQRT_3 / 3.0 * pt.x - 1.0 / 3.0 * pt.y;
                fr = 2.0 / 3.0 * pt.y;
            }
            HexOrientation::Flat => {
                fq = 2.0 / 3.0 * pt.x;
                fr = -1.0 / 3.0 * pt.x + SQRT_3 / 3.0 * pt.y;
            }
        }
        let fs = -fq - fr;
        (fq, fr, fs)
    }

    /// Converts a 3D world space position to the nearest integer `HexCoord`.
    pub fn world_to_hex(&self, world_pos: Vec3) -> HexCoord {
        let (fq, fr, fs) = self.world_to_hex_fractional(world_pos);
        HexCoord::round(fq, fr, fs)
    }

    /// Calculates the 3D world positions of all 6 corners of a given hex.
    /// Useful for drawing hex outlines or placing vertices.
    /// The y-coordinate is based on `self.origin_offset.y`.
    pub fn hex_corners_3d(&self, hex: HexCoord) -> [Vec3; 6] {
        let center = self.hex_to_world_3d(hex);
        let mut corners = [Vec3::ZERO; 6];
        for i in 0..6 {
            let angle = match self.orientation {
                HexOrientation::Pointy => std::f32::consts::PI / 180.0 * (60.0 * i as f32 - 30.0),
                HexOrientation::Flat => std::f32::consts::PI / 180.0 * (60.0 * i as f32),
            };
            // For non-uniform hex_size, this calculation would be more complex.
            // Assuming hex_size.x is width-related and hex_size.y is height-related.
            // For simplicity, using average or assuming uniform scaling if x != y.
            // Here, we use hex_size.x for x-component of corner and hex_size.y for z-component.
            // This might need adjustment based on how hex_size is interpreted for non-uniform hexes.
            // A common approach is to use a single `size` value (radius).
            // If `hex_size` is `Vec2(radius, radius)`, then this is correct.
            let corner_offset = Vec3::new(
                self.hex_size.x * angle.cos(),
                0.0,
                self.hex_size.y * angle.sin(),
            );
            corners[i] = center + corner_offset;
        }
        corners
    }
}
